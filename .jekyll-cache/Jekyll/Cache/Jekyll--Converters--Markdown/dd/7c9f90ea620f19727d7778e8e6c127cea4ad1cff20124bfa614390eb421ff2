I"®<h2 id="ember-rails">Ember-Rails</h2>

<p>Unter Hochzeit versteht man in der Automobilindustrie die Vereinigung
von Fahrgestell, Motor und Karosserie, die zun√§chst als Komponenten
hergestellt wurden.</p>

<p>So eine √§hnliche Hochzeit stand nun f√ºr unsere in Ember.js geschriebene
Client-Applikation der Vertragskalkulation mit dem restlichen
Webshopsystem ins Haus.</p>

<p>Zur Integration der beiden gibt es das Ember-Rails Gem:
<a href="https://github.com/emberjs/ember-rails">https://github.com/emberjs/ember-rails</a></p>

<p>Es stellt das Asset Handling komplett unter die Kontrolle der Rails
Asset Pipeline. Die Umstellung diesbez√ºglich, sowohl f√ºr Entwicklungs-
als auch f√ºr Produktivumgebung, war in etwas mehr als einem Tag zu
schaffen. Hier haben wir wieder alle als Team am gleichen Problem
gearbeitet, da wir diese Integration f√ºr eine wesentliche Komponente mit
Zukunftsfolgen halten.</p>

<p>Zuvor haben wir noch s√§mtliches Javascript der Applikation einheitlich
auf Coffeescript umgestellt. Dies hat zwar mehr Konsistenzgr√ºnde als
realen Nutzen, war aber immerhin eine gute √úbung zur Festigung unseres
CoffeeScript-Know Hows.</p>

<p>Die Kopplung der Datenmodelle zwischen Frontend und Backend ist
implementiert, wir k√∂nnen nun alle Daten automatisch im Hintergrund
√ºbertragen, wenn dies vom Vertriebsmitarbeiter angefordert wird.</p>

<h2 id="promises">Promises</h2>

<p>Wir m√ºssen hier kurz auf das Konzept der Promises zu sprechen kommen, da
es f√ºr uns alle neu ist. Bei asynchroner Programmierung erh√§lt man als
R√ºckgabewert auf einen Funktionsaufruf nicht des ermittelte Ergebnis,
wenn dieses denn in Folge ermittelt worden ist, sondern nur ein Objekt,
eben ein Promise, dieses aber unmittelbar ohne Zeitverz√∂geruung. Es
handelt sich dabei quasi um ein Versprechen auf einen R√ºchgabewert, die
eigentliche Funktion wird asynchron, man k√∂nnte sagen im Hintergrund,
ausgef√ºhrt. Ein Promise wird in Folge im Erfolgsfall erf√ºllt (fulfilled)
oder im Fehlerfall zur√ºckgewiesen (rejected), z.B. wenn der Server die
Anfrage nicht akzeptiert. Auf Fehler- und Erfolsfall kann dann synchron
geantwortet werden.</p>

<p>Dieses Konzept zu verstehen, ist ein Schritt, es erfolgreich zu
verwenden und das Behandeln der Promises richtig zu implementieren ein
weiterer. Selten ist uns bisher ein Programmierparadigma so fundamental
vorgekommen, vergleichbar etwa mit Objektorientierung oder dem MVC
Pattern. Es erm√∂glich eine v√∂llig neue Art der funktionalen
Programmierung, im Internet teilweise ‚Äúreaktive Programmierung‚Äù
genannt.</p>

<p>Immer wieder waren wir - bei falscher asynchroner Implementierung -
√ºberrascht keine R√ºckgabewerte zu erhalten, dabei haben wir diese durch
Ignorierung der Promises einfach ignoriert oder das Ergebnis nicht
synchron abgewartet.</p>

<h2 id="single-page-apps">Single Page Apps</h2>

<p>Ember.js Applikationen sind typischerweise Single Page Apps, so auch
unsere Applikation. In derartigen Applikationen ist es √ºblich, nur
ge√§nderte Bildschirmbereiche zu aktualisieren, nicht aber von einer
Sicht auf eine andere zu wechseln, was wir allerdings noch derzeit
machen. Wir senden den Benutzer zwischen der Vertragsliste,</p>

<hr />

<p><img src="/img/blog/vertragsliste.png" alt="Vertragsliste" style="max-width: 100%" /></p>
<hr />

<p>der Einzelansicht eines Vertrages mit seinen Positionen und der</p>

<hr />

<p><img src="/img/blog/vertrag.png" alt="Vertrag" style="max-width: 100%" /></p>
<hr />

<p>Einzelansicht einer Vertragsposition mit ihren Verbr√§uchen hin und her.</p>

<hr />

<p><img src="/img/blog/position.png" alt="Vertragsposition" style="max-width: 100%" /></p>
<hr />

<p>Das ist eigentlich f√ºr Single Page Apps un√ºblich und wir beschlie√üen
dieses Verhalten zu √§ndern.</p>

<p>Bei aller Begeisterung f√ºr unsere neue Applikation stellen wir im Test
in der Wochenbesprechung fest, dass Positionen nicht gel√∂scht werden
k√∂nnen und √Ñnderungen nicht am Server persistiert werden. Es gibt noch
einiges zu tun!</p>
:ET