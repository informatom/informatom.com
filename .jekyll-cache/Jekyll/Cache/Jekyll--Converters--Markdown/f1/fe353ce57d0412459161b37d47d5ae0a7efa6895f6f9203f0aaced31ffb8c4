I"V<h2 id="die-produktentwicklungsstrategie">Die Produktentwicklungsstrategie</h2>

<p>P√ºnktlich mit dem Installationsbeginn f√ºr des dritte Referenzsystem
konnten wir eine L√∂sung unseres Hauptproblems in der Strategie der
Produktentwicklung l√∂sen.</p>

<p>Das Problem besteht kurz zusammengefasst darin, dass es m√∂glich sein
soll Features kunden√ºbergreifend aber auch kundenspezifisch entwickeln
zu k√∂nnen. Ebenso m√ºssen gewisse Konfigurationen (wie Layout, Styling, etc)
kunden√ºbergreifend durchzuf√ºhren sein, andere kundenspzifisch.</p>

<p>Einen Teil dieses Problems hatten wir damit gel√∂st, dass wir einzelne
Module (in Form von Rubygems und Rails Engines ausgef√ºhrt) erstellt
haben, wie die ERP-Schnittstelle. Schon beim zweiten Referenzsystem
hatten wir aber die Schwierigkeit,
dass alle Gems installiert werden m√ºssen, da des Gemfile ‚Äúmitten‚Äù in
der Applikation liegt und damit kunden√ºbergreifend ist.</p>

<p>Wir haben die Steuerung zun√§chst √ºber Rails Environments zu trennen
versucht, aber auch dabei m√ºssen in allen Systemen alle Gems installiert
werden. Das Thema unterschiedlichen Layouts (CSS Files, DRYML Tags) hatten wir
√ºberhaupt noch ignoriert.</p>

<p>Wir haben auch versucht, m√∂glichst viele Einstellungen in die Datenbank
zu verlegen. Bei den oben genannten Beispielen ist dies aber nicht
m√∂glich. Wir haben damit nur bei etwa 10 Dateien ein Problem, diese bei jedem
Update manuell systemspezifisch einzuspielen, ist aber einfach zu viel
Aufwand und zu fehleranf√§llig.</p>

<p>Doch dann kam die Erleuchtung in Form von Symlinks und
systemspezifischen Code-Repositiories. Das bedarf einer Erkl√§rung, da
der Ansatz eigentlich sehr einfach, aber nicht verbreitet ist.
Die genannten 5-10 Dateien, werden in der Applikation durch symbolische
Link auf Dateien innerhalb eines kunden- oder systemspezifischen
Verzeichnisses (/vendor/customer) ersetzt.</p>

<p>Dieses Verzeichnis ist in einem getrennten Code-Repository. Damit
reduziert das Deployment, das wir ohnehin per Git durchf√ºhren auf einen
zweiten Pull-Vorgang, der auch per Script automatisiert
werden k√∂nnte.</p>

<p>Auf Entwicklungsrechnern kann damit sogar rasch zwischen mehreren
Systemen durch eine weitere Indirektion gewechselt werden:
Pro System gibt es ein Verzeichnis innerhalb von <code>/vendor/customers</code></p>
<ul>
  <li>man bemerke das ‚Äòs‚Äô!). Und /vendor/customer linkt immer aus des gerade
betrachtete System.</li>
</ul>

<hr />

<p><img src="/img/blog/indirection.png" alt="Indirektion" style="max-width: 100%" /></p>
<hr />

<p>Im Zuge dessen haben wir die Repositories f√ºr alle 6 Systeme (3
Referenzsysteme mit je einem Entwicklungs- und einem Stagingsystem)
angelegt und tranportiert.</p>

<p>Wir haben das System nun auf allen Rechnern und Servern getestet, es
funktioniert problemlos.</p>

<p>Damit k√∂nnen wir weitere Modularisierungen, wie etwa die Umwandlung der
eigentlichen Applikation in eine Engine auf einen wesentlich sp√§teren
Zeitpunkt verschieben evtl sogar ganz absagen.</p>

<h2 id="vermischtes">Vermischtes</h2>

<p>F√ºr das erste Referenzsystem wurden einige Arbeiten durchgef√ºhrt:</p>

<ul>
  <li>kleine Layoutanpassungen</li>
  <li>Erstellung eines alternativen Importjobs f√ºr Kategorien</li>
  <li>Es gibt ein Script zum Testen der Vollst√§ndigkeit der Kategorien
(gibt es f√ºr jedes Produkt wenigstens eine Kategorie, in der es
zugeordnet ist?)</li>
  <li>Neuimport der Produkte</li>
  <li>Ein Systemupdate auf eine neuere Betriebssystemversion wurde
durchf√ºhrt (Ubuntu 12.04 auf Ubuntu 14.04). Es gab hierbei
keinerlei Probleme. Mercator ist mit beiden Versionen
voll kompatibel.</li>
  <li>Das zweite Referenzsystem ist nun installiert und kann mit Daten
bef√ºllt werden.</li>
  <li>Wir haben ein Modul zum Tracken der User installiert. Damit werden
wir etwa verfolgen k√∂nnen, ab Benutzer im Shop herumirren oder
effektiv Produkte finden und bestellen k√∂nnen.</li>
</ul>
:ET